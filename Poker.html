<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Texas Hold'em</title>
<style>
  :root{
    --bg:#070707;
    --panel:#0f1112;
    --muted:#cfcfcf;
    --accent:#d4af37;
    --felt:#0e4a2c;
    --danger:#cc1f1f;
    --card:#ffffff;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg, #040404 0%, #071010 100%);
    color:var(--muted);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    padding:22px;
  }
  .wrap{max-width:1120px;margin:0 auto}
  header{display:flex;align-items:center;gap:14px;margin-bottom:18px}
  h1{margin:0;font-size:20px;letter-spacing:0.2px}
  .table{
    background: linear-gradient(180deg, rgba(5,30,10,0.95) 0%, rgba(8,18,10,0.9) 100%);
    border-radius:14px;padding:20px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    border: 1px solid rgba(212,175,55,0.06);
  }
  .top-row{display:flex;justify-content:space-between;align-items:center;gap:16px}
  .board{display:flex;flex-direction:column;gap:12px;margin-top:14px}
  .community{
    display:flex;gap:12px;justify-content:center;align-items:center;padding:10px;
  }
  .card{
    width:78px;height:108px;border-radius:10px;background:var(--card);
    display:flex;flex-direction:column;justify-content:space-between;padding:8px;color:#111;
    box-shadow:0 6px 18px rgba(0,0,0,0.5);font-weight:700;border:1px solid rgba(0,0,0,0.06);
    transition:transform 0.25s ease;
  }
  .card.deal-anim{transform:translateY(-6px)}
  .card .top{font-size:15px}
  .card .suit{font-size:34px;text-align:center}
  .card.empty{
    background:transparent;border:2px dashed rgba(255,255,255,0.06);
    color:var(--muted);display:flex;align-items:center;justify-content:center;
    height:108px;width:78px;border-radius:10px
  }
  .hud{display:flex;gap:18px;align-items:center;justify-content:center;padding:10px;margin-top:6px}
  .hud .pill{background:var(--glass);padding:10px 12px;border-radius:10px;font-weight:700;border:1px solid rgba(255,255,255,0.02)}
  .controls{display:flex;gap:8px;justify-content:center;margin-top:12px;align-items:center}
  button{background:var(--accent);border:none;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:700;color:#081010;letter-spacing:0.3px}
  button.gray{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  button.red{background:var(--danger);color:#fff}
  .players{display:flex;justify-content:space-between;align-items:flex-end;margin-top:18px;gap:8px}
  .player{
    flex:1;display:flex;flex-direction:column;gap:8px;align-items:center;padding:10px;border-radius:10px;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    border:1px solid rgba(255,255,255,0.02)
  }
  .player .name{font-weight:800;color:var(--card)}
  .player .chips{font-weight:700;color:var(--muted)}
  .player .hole{display:flex;gap:8px}
  .player .status{font-size:13px;color:var(--muted);opacity:0.9}
  .log{height:160px;overflow:auto;background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);font-size:13px}
  .controls .bet-box{display:flex;align-items:center;gap:8px;background:var(--panel);padding:8px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  input[type=range]{width:210px}
  .status{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);font-weight:700;text-align:center}
  footer{margin-top:12px;color:var(--muted);font-size:13px;text-align:center;opacity:0.9}
  .muted{color:var(--muted);opacity:0.9}
  .row{display:flex;gap:12px;align-items:center}
  .winner{outline:2px solid rgba(212,175,55,0.7)}
  @media(max-width:900px){
    .players{flex-direction:column}
    .card{width:56px;height:78px}
    .card.empty{height:78px;width:56px}
    .community{flex-wrap:wrap}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Texas Hold'em</h1>
  </header>

  <div class="table">
    <div class="top-row">
      <div class="row">
        <div class="hud">
          <div class="pill">Pot: <span id="pot">0</span></div>
          <div class="pill">Current Bet: <span id="currentBet">0</span></div>
          <div class="pill">Big Blind: <span id="bigBlind">50</span></div>
          <div class="pill">Min Raise: <span id="minRaise">50</span></div>
        </div>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <div class="status" id="status">Press DEAL to start a hand</div>
        <div style="display:flex;gap:8px;margin-left:6px">
          <button id="btnDeal">Deal</button>
          <button id="btnReset" class="gray">Reset Chips</button>
        </div>
      </div>
    </div>

    <div class="board">
      <div class="community" id="communityArea"></div>

      <div class="controls" id="controls" style="display:none">
        <button id="btnFold" class="red">Fold</button>
        <button id="btnCheck" class="gray">Check / Call</button>
        <button id="btnBet">Bet / Raise</button>

        <div class="bet-box">
          <input id="betRange" type="range" min="10" max="2000" value="100">
          <div class="muted">Amt: <strong id="betVal">100</strong></div>
        </div>
      </div>

      <div class="players" id="playersArea"></div>

      <div style="display:flex;gap:12px;margin-top:12px;align-items:flex-start">
        <div style="flex:1"><div class="log" id="log"></div></div>
        <div style="width:320px;display:flex;flex-direction:column;gap:8px">
          <div class="status">Round info & controls</div>
          <div style="display:flex;gap:8px;justify-content:flex-end">
            <button id="btnShowdown" class="gray">Force Showdown</button>
            <button id="btnNextHand" class="gray">Next Hand</button>
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
/* ---------------------------
  Texas Hold'em — complete build
  - Blinds, betting rounds, min-raise
  - All-ins + side pots
  - Best 5 from 7-card evaluator
  - Random-but-legal opponents
  - Show all hole cards at showdown and announce winners
--------------------------------*/

const SUITS = ['♠','♥','♦','♣'];
const RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];

function makeDeck(){ const d=[]; for(const s of SUITS) for(const r of RANKS) d.push({suit:s,rank:r}); return d; }
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }

function cardToHtml(card,show=true){
  if(!card) return `<div class="card empty">?</div>`;
  if(!show) return `<div class="card" style="background:#0b1a14;color:var(--muted)"><div style="text-align:center;opacity:0.6">?</div></div>`;
  const red = (card.suit==='♥'||card.suit==='♦') ? 'color:#b22' : '';
  return `<div class="card"><div class="top" style="${red}">${card.rank}</div><div class="suit" style="${red}">${card.suit}</div><div class="top" style="${red}">${card.rank}</div></div>`;
}

/* ---------- State ---------- */
let state = {};
function initState(){
  state = {
    deck:[],
    community:[],
    players:[],
    pot:0,
    currentBet:0,
    minRaise:50,
    dealer:-1,
    sb:25,
    bb:50,
    round:'waiting', // 'pre','flop','turn','river','showdown','waiting'
    actingIndex:0,
    bettingRoundActive:false,
    lastRaiser:-1,
    log:[],
  };
  state.players = [
    {name:'You', chips:2000, hole:[], folded:false, inHand:true, bet:0, acted:false, allin:false, committed:0},
    {name:'Seat 2', chips:2000, hole:[], folded:false, inHand:true, bet:0, acted:false, allin:false, committed:0},
    {name:'Seat 3', chips:2000, hole:[], folded:false, inHand:true, bet:0, acted:false, allin:false, committed:0},
    {name:'Seat 4', chips:2000, hole:[], folded:false, inHand:true, bet:0, acted:false, allin:false, committed:0},
  ];
  document.getElementById('bigBlind').innerText = state.bb;
  document.getElementById('minRaise').innerText = state.minRaise;
  renderAll();
  log('Ready. Press DEAL to start a hand.');
}
function resetChips(){ for(const p of state.players) p.chips=2000; initState(); }

/* ---------- Render ---------- */
function renderCommunity(){
  const area = document.getElementById('communityArea'); area.innerHTML='';
  for(let i=0;i<5;i++){
    const c = state.community[i];
    area.innerHTML += c ? cardToHtml(c,true) : `<div class="card empty">${i<3? 'Hidden':''}</div>`;
  }
}
function renderPlayers(){
  const pa = document.getElementById('playersArea'); pa.innerHTML='';
  state.players.forEach((p,idx)=>{
    const div = document.createElement('div'); div.className='player';
    if(idx===0) div.style.border = `1px solid rgba(212,175,55,0.22)`;
    const name = document.createElement('div'); name.className='name'; name.innerText = p.name + (idx===state.dealer? ' (D)':'' );
    const chips = document.createElement('div'); chips.className='chips'; chips.innerText = 'Chips: ' + p.chips;
    const hole = document.createElement('div'); hole.className='hole';
    const revealHole = (state.round==='showdown' || idx===0);
    if(p.hole && p.hole.length>0){
      hole.innerHTML = p.hole.map(c=> revealHole ? cardToHtml(c,true) : (idx===0 ? cardToHtml(c,true) : cardToHtml(c,false))).join('');
    } else {
      hole.innerHTML = cardToHtml(null);
    }
    const status = document.createElement('div'); status.className='status';
    let sarr = [];
    if(p.folded) sarr.push('Folded');
    if(p.allin) sarr.push('All-in');
    if(!p.inHand) sarr.push('Out');
    if(p.bet) sarr.push('Bet:'+p.bet);
    status.innerText = sarr.join(' ');
    if(idx===state.actingIndex && state.bettingRoundActive && !p.folded && !p.allin){
      status.innerText = (status.innerText? status.innerText + ' • ':'') + 'To Act';
      div.style.boxShadow = '0 8px 30px rgba(212,175,55,0.06)';
    }
    div.appendChild(name); div.appendChild(hole); div.appendChild(chips); div.appendChild(status);
    pa.appendChild(div);
  });
}
function renderHud(){
  document.getElementById('pot').innerText = state.pot;
  document.getElementById('currentBet').innerText = state.currentBet;
  document.getElementById('minRaise').innerText = state.minRaise;
  document.getElementById('betVal').innerText = document.getElementById('betRange').value;
}
function renderAll(){
  renderCommunity(); renderPlayers(); renderHud();
  const logEl = document.getElementById('log');
  logEl.innerHTML = state.log.slice(-150).map(l=>`<div>${l}</div>`).join('');
  logEl.scrollTop = logEl.scrollHeight;
}

/* ---------- Logging ---------- */
function log(s){ state.log.push((new Date()).toLocaleTimeString()+' — '+s); renderAll(); }

/* ---------- Helpers ---------- */
function afterShort(fn){ setTimeout(fn, 250 + Math.random()*400); }
function commitPut(player, amt){
  if(!player || amt<=0) return;
  const put = Math.min(amt, player.chips);
  player.chips -= put;
  player.committed = (player.committed||0) + put;
  if(player.chips===0) player.allin = true;
}

/* ---------- Game flow ---------- */
function startHand(){
  state.deck = makeDeck(); shuffle(state.deck);
  state.community = [];
  state.pot = 0;
  state.currentBet = 0;
  state.minRaise = state.bb;
  state.round = 'pre';
  state.lastRaiser = -1;

  for(const p of state.players){
    p.hole = []; p.folded=false; p.inHand = p.chips>0; p.bet=0; p.acted=false; p.allin=false; p.committed=0;
  }

  state.dealer = (state.dealer+1) % state.players.length;
  const sbIdx = nextOccupied((state.dealer+1) % state.players.length);
  const bbIdx = nextOccupied((sbIdx+1) % state.players.length);

  postBlind(sbIdx, state.sb);
  postBlind(bbIdx, state.bb);

  // Deal two hole cards round-robin
  for(let r=0;r<2;r++){
    for(let i=0;i<state.players.length;i++){
      const idx = nextOccupied((state.dealer+1+i) % state.players.length);
      if(idx===-1) continue;
      const p = state.players[idx];
      if(p.inHand) p.hole.push(state.deck.pop());
    }
  }

  state.actingIndex = nextOccupied((bbIdx+1)%state.players.length);
  state.currentBet = state.bb;
  state.bettingRoundActive = true;

  for(const p of state.players) p.acted = (p.folded || p.allin) ? true : false;
  for(const p of state.players) if(!p.folded && !p.allin) p.acted = false;

  log(`Dealt — Dealer: ${state.players[state.dealer].name}. SB: ${state.players[sbIdx].name} (${state.sb}), BB: ${state.players[bbIdx].name} (${state.bb})`);
  renderAll();
  afterShort(()=>ensureNextActor());
}

function nextOccupied(start){
  for(let i=0;i<state.players.length;i++){
    const idx = (start+i)%state.players.length;
    if(state.players[idx].chips>0 || state.players[idx].bet>0) return idx;
  }
  return -1;
}
function postBlind(idx,amt){
  const p = state.players[idx];
  const toPut = Math.min(amt, p.chips);
  commitPut(p, toPut);
  p.bet += toPut;
  state.pot += toPut;
  log(`${p.name} posts ${toPut}${toPut<amt? ' (all-in)':''}`);
}

/* ---------- Betting round control ---------- */
function bettingRoundComplete(){
  const active = state.players.filter(p=>!p.folded);
  if(active.length<=1) return true;
  const need = state.players.filter(p=>!p.folded && !p.allin);
  if(need.length===0) return true;
  const allGood = need.every(p => p.acted && p.bet === state.currentBet);
  return allGood;
}

function ensureNextActor(){
  const contenders = state.players.filter(p=>!p.folded);
  if(contenders.length===1){
    const winner = contenders[0];
    winner.chips += state.pot;
    log(`${winner.name} wins pot ${state.pot} (others folded)`);
    document.getElementById('status').innerText = `${winner.name} wins pot ${state.pot} (others folded)`;
    state.pot = 0;
    state.bettingRoundActive = false;
    state.round = 'waiting';
    renderAll();
    return;
  }

  if(bettingRoundComplete()){
    state.bettingRoundActive = false;
    // move bets to pot and reset per-player bet
    for(const p of state.players){ state.pot += p.bet; p.bet = 0; }
    if(state.round==='pre'){ revealFlop(); return; }
    if(state.round==='flop'){ revealTurn(); return; }
    if(state.round==='turn'){ revealRiver(); return; }
    if(state.round==='river'){ doShowdown(); return; }
  }

  // find next actor
  let start = state.actingIndex;
  for(let i=0;i<state.players.length;i++){
    const idx = (start + i) % state.players.length;
    const p = state.players[idx];
    if(p.folded || p.allin) continue;
    if(p.bet < state.currentBet || !p.acted){
      state.actingIndex = idx;
      renderAll();
      if(idx===0){
        enableControls(true);
        const toCall = Math.max(0, state.currentBet - state.players[0].bet);
        document.getElementById('status').innerText = `Your turn — to call: ${toCall}`;
      } else {
        enableControls(false);
        document.getElementById('status').innerText = `${state.players[idx].name} is thinking...`;
        afterShort(()=>opponentAct(idx));
      }
      return;
    }
  }
  // fallback: mark round complete
  state.bettingRoundActive = false;
  ensureNextActor();
}

/* ---------- Opponents ---------- */
function opponentAct(idx){
  const p = state.players[idx];
  if(p.folded || p.allin){ state.actingIndex = (idx+1)%state.players.length; ensureNextActor(); return; }
  const toCall = state.currentBet - p.bet;
  const canRaise = p.chips > toCall + state.minRaise;
  const rnd = Math.random();

  // rough strength heuristic (preflop only)
  const strength = preflopStrength(p.hole);

  if(toCall>0){
    if(p.chips <= toCall || rnd < 0.4 + strength*0.2){
      const amt = Math.min(toCall, p.chips);
      commitPut(p, amt); p.bet += amt; state.pot += amt;
      log(`${p.name} calls ${amt}`);
      p.acted = true;
    } else if(canRaise && rnd < 0.7){
      const raise = Math.min(p.chips - toCall, Math.max(state.minRaise, Math.floor((state.minRaise) * (1 + strength*3))));
      const put = Math.min(p.chips, toCall + raise);
      commitPut(p, put); p.bet += put; state.pot += put;
      state.currentBet = p.bet;
      state.minRaise = raise;
      state.lastRaiser = idx;
      for(const op of state.players) if(!op.folded && !op.allin) op.acted = (op === p);
      log(`${p.name} raises to ${p.bet}`);
    } else {
      p.folded = true; p.acted = true;
      log(`${p.name} folds`);
    }
  } else {
    if(rnd < 0.6 - strength*0.2){
      log(`${p.name} checks`);
      p.acted = true;
    } else {
      const betAmt = Math.min(p.chips, Math.max(state.minRaise, Math.floor(state.bb * (1 + strength*3))));
      if(betAmt>0){
        commitPut(p, betAmt); p.bet += betAmt; state.pot += betAmt;
        state.currentBet = p.bet;
        state.minRaise = betAmt;
        state.lastRaiser = idx;
        for(const op of state.players) if(!op.folded && !op.allin) op.acted = (op === p);
        log(`${p.name} bets ${betAmt}`);
      } else {
        log(`${p.name} checks`);
        p.acted = true;
      }
    }
  }
  if(p.chips===0) p.allin=true;
  state.actingIndex = (idx+1)%state.players.length;
  renderAll();
  afterShort(()=>ensureNextActor());
}

function preflopStrength(hole){
  if(!hole || hole.length<2) return 0;
  const r1 = RANKS.indexOf(hole[0].rank), r2 = RANKS.indexOf(hole[1].rank);
  const pair = hole[0].rank===hole[1].rank ? 1 : 0;
  const high = Math.max(r1,r2);
  const suited = hole[0].suit===hole[1].suit ? 0.2 : 0;
  const gap = Math.abs(r1-r2);
  const connector = gap===1 ? 0.1 : (gap===2 ? 0.05 : 0);
  return Math.min(1, pair*0.8 + (high/12)*0.5 + suited + connector);
}

/* ---------- User controls ---------- */
function enableControls(on){ document.getElementById('controls').style.display = on? 'flex':'none'; }
document.getElementById('betRange').oninput = (e)=>{ document.getElementById('betVal').innerText = e.target.value; };

document.getElementById('btnFold').onclick = ()=>{
  const p = state.players[0];
  p.folded = true; p.acted = true;
  log('You fold');
  state.actingIndex = nextIndex(state.actingIndex);
  enableControls(false);
  afterShort(()=>ensureNextActor());
};

document.getElementById('btnCheck').onclick = ()=>{
  const p = state.players[0];
  const toCall = state.currentBet - p.bet;
  if(toCall > 0){
    const amt = Math.min(toCall, p.chips);
    commitPut(p, amt); p.bet += amt; state.pot += amt;
    log('You call ' + amt);
    p.acted = true;
  } else {
    log('You check');
    p.acted = true;
  }
  state.actingIndex = nextIndex(0);
  enableControls(false);
  afterShort(()=>ensureNextActor());
};

document.getElementById('btnBet').onclick = ()=>{
  const p = state.players[0];
  const val = Number(document.getElementById('betRange').value);
  const toCall = state.currentBet - p.bet;
  if(toCall>0){
    const raiseAmount = val; // slider is raise amount above call
    if(raiseAmount < state.minRaise) { log(`Raise must be at least ${state.minRaise}.`); return; }
    const totalPut = Math.min(p.chips, toCall + raiseAmount);
    commitPut(p, totalPut); p.bet += totalPut; state.pot += totalPut;
    state.currentBet = p.bet;
    state.minRaise = raiseAmount;
    state.lastRaiser = 0;
    for(const op of state.players) if(!op.folded && !op.allin) op.acted = (op === p);
    log(`You raise to ${p.bet}`);
  } else {
    const put = Math.min(p.chips, val);
    if(put <= 0){ log('Invalid bet amount'); return; }
    commitPut(p, put); p.bet += put; state.pot += put;
    state.currentBet = p.bet;
    state.minRaise = Math.max(state.minRaise, put);
    state.lastRaiser = 0;
    for(const op of state.players) if(!op.folded && !op.allin) op.acted = (op === p);
    log(`You bet ${p.bet}`);
  }
  if(p.chips===0) p.allin=true;
  p.acted = true;
  state.actingIndex = nextIndex(0);
  enableControls(false);
  afterShort(()=>ensureNextActor());
};

function nextIndex(i){
  for(let k=1;k<=state.players.length;k++){
    const idx = (i+k) % state.players.length;
    if(!state.players[idx].inHand) continue;
    return idx;
  }
  return (i+1)%state.players.length;
}

/* ---------- Round reveals ---------- */
function revealFlop(){
  if(state.deck.length>0) state.deck.pop(); // burn
  state.community.push(state.deck.pop(), state.deck.pop(), state.deck.pop());
  state.round='flop';
  state.actingIndex = nextOccupied((state.dealer+1)%state.players.length);
  state.currentBet = 0; state.minRaise = state.bb; state.bettingRoundActive = true;
  for(const p of state.players){ p.acted = (p.folded || p.allin) ? true : false; if(!p.folded && !p.allin) p.acted=false; }
  log('Flop: ' + state.community.map(c=>c.rank+c.suit).join(' '));
  renderAll();
  afterShort(()=>ensureNextActor());
}
function revealTurn(){
  if(state.deck.length>0) state.deck.pop();
  state.community.push(state.deck.pop());
  state.round='turn';
  state.actingIndex = nextOccupied((state.dealer+1)%state.players.length);
  state.currentBet = 0; state.minRaise = state.bb; state.bettingRoundActive = true;
  for(const p of state.players){ p.acted = (p.folded || p.allin) ? true : false; if(!p.folded && !p.allin) p.acted=false; }
  log('Turn: ' + state.community.map(c=>c.rank+c.suit).join(' '));
  renderAll();
  afterShort(()=>ensureNextActor());
}
function revealRiver(){
  if(state.deck.length>0) state.deck.pop();
  state.community.push(state.deck.pop());
  state.round='river';
  state.actingIndex = nextOccupied((state.dealer+1)%state.players.length);
  state.currentBet = 0; state.minRaise = state.bb; state.bettingRoundActive = true;
  for(const p of state.players){ p.acted = (p.folded || p.allin) ? true : false; if(!p.folded && !p.allin) p.acted=false; }
  log('River: ' + state.community.map(c=>c.rank+c.suit).join(' '));
  renderAll();
  afterShort(()=>ensureNextActor());
}

/* ---------- Showdown & Side-pots ---------- */
function doShowdown(){
  if(state.round==='waiting') return;
  state.round='showdown';
  // move remaining bets to pot
  for(const p of state.players){ state.pot += p.bet; p.bet = 0; }
  renderAll();

  // Build side-pots from committed amounts (chips put in this hand)
  const contrib = state.players.map(p => p.committed||0);
  const pots = [];
  const working = contrib.slice();

  while(true){
    const positive = working.filter(c=>c>0);
    if(positive.length===0) break;
    const slice = Math.min(...positive);
    const eligibleIdx = [];
    for(let i=0;i<working.length;i++) if(working[i]>0) eligibleIdx.push(i);
    const potAmt = slice * eligibleIdx.length;
    pots.push({amount:potAmt, eligible:eligibleIdx.slice()});
    for(let i=0;i<working.length;i++) if(working[i]>0) working[i]-=slice;
  }

  // Announce all players' hand names at showdown
  const everyone = state.players.map((p, i) => {
    const hand = bestHand(p.hole.concat(state.community));
    return {idx:i, name:p.name, folded:p.folded, hand};
  });
  everyone.forEach(e=>{
    if(e.folded){
      log(`${e.name}: Folded`);
    } else {
      log(`${e.name}: ${handName(e.hand)} (${prettyHand(e.hand)})`);
    }
  });

  // Evaluate each pot and split among best hands (tie shares)
  const summaries = [];
  for(const pot of pots){
    const elig = pot.eligible.filter(i => !state.players[i].folded);
    if(elig.length===0) continue;
    const evals = elig.map(i => {
      const cards7 = state.players[i].hole.concat(state.community);
      return {idx:i, hand: bestHand(cards7)};
    });
    evals.sort((a,b)=>compareHands(b.hand, a.hand));
    const top = evals[0].hand;
    const winners = evals.filter(e=>compareHands(e.hand, top)===0).map(e=>e.idx);
    const share = Math.floor(pot.amount / winners.length);
    for(const w of winners) state.players[w].chips += share;
    summaries.push(`Pot ${pot.amount} -> ${winners.map(i=>state.players[i].name).join(', ')} each ${share} with ${handName(top)}`);
  }

  summaries.forEach(s=>log(s));

  state.pot = 0;
  state.round='waiting';
  highlightWinners();
  renderAll();

  // Announce winners in status bar
  if(summaries.length){
    document.getElementById('status').innerText = summaries.join(' | ');
  } else {
    document.getElementById('status').innerText = 'Showdown complete.';
  }
}

function highlightWinners(){
  // outline winners' player blocks based on overall best hand (final comparison, not per side-pot)
  const pa = document.getElementById('playersArea');
  const alive = state.players.map((p,i)=>({i,p})).filter(x=>!x.p.folded);
  if(!alive.length) return;
  const evals = alive.map(x=>({i:x.i, hand: bestHand(state.players[x.i].hole.concat(state.community))}));
  evals.sort((a,b)=>compareHands(b.hand,a.hand));
  const best = evals[0].hand;
  const winners = evals.filter(e=>compareHands(e.hand,best)===0).map(e=>e.i);
  const blocks = pa.querySelectorAll('.player');
  winners.forEach(i=>{
    const block = blocks[i];
    if(block) block.classList.add('winner');
  });
}

/* ---------- Hand evaluator ---------- */
const HAND_RANKS = ['High Card','Pair','Two Pair','Trips','Straight','Flush','Full House','Quads','Straight Flush'];

function handName(h){ return HAND_RANKS[h.rank]; }

function prettyHand(h){
  // human-friendly description of tiebreaks
  const toCard = r => ['2','3','4','5','6','7','8','9','10','J','Q','K','A'][r];
  if(h.rank===8) return `${toCard(h.tiebreak[0])}-high`;
  if(h.rank===7) return `(${toCard(h.tiebreak[0])}s)`;
  if(h.rank===6) return `${toCard(h.tiebreak[0])} over ${toCard(h.tiebreak[1])}`;
  if(h.rank===5) return h.tiebreak.map(toCard).join(' ');
  if(h.rank===4) return `${toCard(h.tiebreak[0])}-high`;
  return h.tiebreak.map(toCard).join(' ');
}

function bestHand(cards){
  const combos = k_combinations(cards,5);
  let best = null;
  for(const c of combos){
    const h = evaluate5(c);
    if(!best || compareHands(h,best)>0) best = h;
  }
  return best;
}

function evaluate5(cards){
  const ranks = cards.map(c=>RANKS.indexOf(c.rank)).sort((a,b)=>b-a);
  const suits = cards.map(c=>c.suit);

  // counts by rank
  const counts = {}; for(const r of ranks) counts[r]= (counts[r]||0)+1;
  const countsArr = Object.entries(counts).map(([k,v])=>({r:+k,c:v}))
    .sort((a,b)=>{ if(b.c!==a.c) return b.c-a.c; return b.r-a.r; });

  const isFlush = suits.every(s=>s===suits[0]);

  // straight detection including A-5 wheel
  const distinct = [...new Set(ranks)].sort((a,b)=>b-a);
  let isStraight=false, topStraight=null;
  if(distinct.length>=5){
    for(let i=0;i<=distinct.length-5;i++){
      const window = distinct.slice(i,i+5);
      if(window[0]-window[4]===4){ isStraight=true; topStraight=window[0]; break; }
    }
  }
  if(!isStraight){
    // wheel: A(12) 5(3) 4(2) 3(1) 2(0)
    const set = new Set(ranks);
    if(set.has(12)&&set.has(3)&&set.has(2)&&set.has(1)&&set.has(0)){ isStraight=true; topStraight=3; }
  }

  if(isFlush && isStraight) return {rank:8, tiebreak:[topStraight]};
  if(countsArr[0].c===4) return {rank:7, tiebreak:[countsArr[0].r, countsArr[1].r]};
  if(countsArr[0].c===3 && countsArr[1] && countsArr[1].c>=2) return {rank:6, tiebreak:[countsArr[0].r, countsArr[1].r]};
  if(isFlush) return {rank:5, tiebreak:ranks};
  if(isStraight) return {rank:4, tiebreak:[topStraight]};
  if(countsArr[0].c===3) return {rank:3, tiebreak:[countsArr[0].r].concat(kickersFromCounts(ranks, countsArr, 1))};
  if(countsArr[0].c===2 && countsArr[1] && countsArr[1].c===2){
    const hiPair = Math.max(countsArr[0].r,countsArr[1].r);
    const loPair = Math.min(countsArr[0].r,countsArr[1].r);
    return {rank:2, tiebreak:[hiPair, loPair].concat(kickersFromCounts(ranks, countsArr, 2))};
  }
  if(countsArr[0].c===2) return {rank:1, tiebreak:[countsArr[0].r].concat(kickersFromCounts(ranks, countsArr, 1))};
  return {rank:0, tiebreak:ranks};
}

function kickersFromCounts(ranks, countsArr, usedPairsOrTrips){
  const used = new Set();
  for(let i=0;i<usedPairsOrTrips;i++) used.add(countsArr[i].r);
  const remaining = ranks.filter(r=>!used.has(r));
  return remaining;
}

function compareHands(a,b){
  if(a.rank!==b.rank) return a.rank-b.rank;
  const len = Math.max(a.tiebreak.length, b.tiebreak.length);
  for(let i=0;i<len;i++){
    const av = a.tiebreak[i] ?? -1;
    const bv = b.tiebreak[i] ?? -1;
    if(av!==bv) return av-bv;
  }
  return 0;
}

function k_combinations(set,k){
  const iSet = Array.from(set);
  function combs(arr,k){
    if(k===0) return [[]];
    if(arr.length<k) return [];
    const [first,...rest]=arr;
    const withFirst = combs(rest,k-1).map(c=>[first,...c]);
    const withoutFirst = combs(rest,k);
    return withFirst.concat(withoutFirst);
  }
  return combs(iSet,k);
}

/* ---------- UI: buttons ---------- */
document.getElementById('btnDeal').onclick = ()=>{
  startHand();
};

document.getElementById('btnReset').onclick = ()=>{ resetChips(); };

document.getElementById('btnShowdown').onclick = ()=>{
  if(state.round!=='waiting') doShowdown();
};

document.getElementById('btnNextHand').onclick = ()=>{
  if(state.round!=='waiting'){
    doShowdown();
    afterShort(startHand);
  } else {
    startHand();
  }
};

// initialize
document.getElementById('betRange').min = 10;
document.getElementById('betRange').max = 2000;
document.getElementById('betRange').value = 100;
document.getElementById('betVal').innerText = document.getElementById('betRange').value;
initState();
</script>
</body>
</html>
